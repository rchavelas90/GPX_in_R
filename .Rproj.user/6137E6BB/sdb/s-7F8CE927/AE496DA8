{
    "contents" : "\n##Description of the function\n##http://plotkml.r-forge.r-project.org/readGPX.html\n##Function Source\n##https://r-forge.r-project.org/scm/viewvc.php/pkg/R/readGPX.R?view=markup&revision=279&root=plotkml\n\n##This function has been modified by Ricardo Chavelas\n###Fixed problem with metadata loading\n###Remove \"Bounds\" loading\n\n##Comments were added for clear undesrtanding by RCM with ##R#\n\n##Future possible actions: \n### Check all code to match exactly with GPX XML shema (and extenions)\n\n##R# Loads XML pakcage\nlibrary(XML)\nreadGPX <- function(\n gpx.file,\n metadata = TRUE,\n waypoints = TRUE, \n tracks = TRUE,  \n routes = TRUE   \n)\n \n{    \n options(warn = -1) ##R# Removes all warnings   \n \n ##R# Reads elements with readGPX.element() function\n if(metadata==TRUE) { metadata <- .readGPX.element(gpx.file, \"metadata\") }     \n if(waypoints==TRUE) { waypoints <- .readGPX.element(gpx.file, \"wpt\") }\n if(tracks==TRUE) { tracks <- .readGPX.element(gpx.file, \"trk\") }\n if(routes==TRUE) { routes <- .readGPX.element(gpx.file, \"rte\") }\n \n \n ##R# creates the named list with all the elements of the GPX file\n gpx <- list(metadata=metadata, waypoints=waypoints, tracks=tracks, routes=routes)\n return(gpx)\n}\n\n## Read various elements from a *.gpx file:\n\n.readGPX.element <- function(gpx.file, element) {\n # element = \"metadata\", \"wpt\", \"rte\", \"trk\", ##R# \"bounds\"\n \n ## gives a internal C-level document pointer \n ret <- xmlTreeParse(gpx.file, useInternalNodes = TRUE)\n # top structure ##R# as a XMLNode object: \n top <- xmlRoot(ret)\n \n # check if there is any content: ##R# XML tag name of each of the sub nodes\n # of a given XMLNode object\n if(any(grep(element, names(top)))) {\n  \n  # tracks:\n  if(element==\"trk\"){   \n   ret <- NULL\n   nu <- which(names(top) %in% element)\n   for(c in seq_along(nu)){\n    lst <- which(names(top[[nu[c]]]) %in% \"trkseg\")\n    nm <- names(top[[nu[c]]][[lst[1]]][[1]])\n    ret[[c]] <- list(NULL)\n    for(i in seq_along(lst)) {\n     trkpt <- top[[nu[c]]][[lst[i]]]\n     ret[[c]][[i]] <- data.frame(NULL)\n     ## get columns (http://www.topografix.com/GPX/1/1/#type_wptType)\n     lon <- as.numeric(xmlSApply(trkpt, xmlGetAttr, \"lon\"))\n     lat <- as.numeric(xmlSApply(trkpt, xmlGetAttr, \"lat\"))\n     ret[[c]][[i]][1:length(lon),\"lon\"] <- lon\n     ret[[c]][[i]][1:length(lat),\"lat\"] <- lat\n     if(!nm[[1]]==\"NULL\"){\n      for(j in 1:length(nm)){\n       xm <- as.character(sapply(sapply(xmlChildren(trkpt), function(x) x[[nm[[j]]]]), xmlValue))\n       ret[[c]][[i]][1:length(xm), nm[[j]]] <- xm \n      }\n     } \n    }\n    names(ret[[c]]) <- xmlValue(top[[nu[c]]][[\"name\"]])\n   }   \n  }\n  \n  if(element==\"wpt\"){\n   ret <- data.frame(NULL)\n   nu <- which(names(top) %in% element)\n   nm <- names(top[[nu[1]]])\n   for(i in seq_along(nu)) {\n    # coordinates:\n    ret[i, \"lon\"] <- as.numeric(xmlGetAttr(top[[nu[i]]], \"lon\"))\n    ret[i, \"lat\"] <- as.numeric(xmlGetAttr(top[[nu[i]]], \"lat\"))\n    if(!nm[[1]]==\"NULL\"){\n     for(j in 1:length(nm)){\n      ret[i, nm[[j]]] <- xmlValue(xmlChildren(top[[nu[i]]])[[nm[[j]]]])\n     }  \n    }\n   }\n  }\n  \n  if(element==\"rte\"){\n   ret <- NULL\n   nu <- which(names(top) %in% element)\n   for(c in seq_along(nu)){\n    ret[[c]] <- data.frame(NULL)\n    lst <- which(names(top[[nu[c]]]) %in% \"rtept\")\n    nm <- names(top[[nu[c]]][[lst[1]]])\n    for(i in seq_along(lst)) {\n     rtept <- top[[nu[c]]][[lst[i]]]\n     ret[[c]][i, \"lon\"] <- as.numeric(xmlGetAttr(rtept, \"lon\"))\n     ret[[c]][i, \"lat\"] <- as.numeric(xmlGetAttr(rtept, \"lat\"))\n     if(!nm[[1]]==\"NULL\"){\n      for(j in c(\"name\",\"cmt\",\"desc\",\"sym\",\"type\")){\n       try(ret[[c]][i, j] <- xmlValue(rtept[[j]]), silent = TRUE)\n      }\n     } \n    }\n    names(ret)[c] <- xmlValue(top[[nu[c]]][[\"name\"]])\n   }\n  }\n  \n  # bounds (is not usefull in this version, however in newer versions may be usefull)\n  if(element==\"bounds\"){\n   nu <- which(names(top) %in% element)\n   ret <- matrix(rep(NA, 4), nrow=2, dimnames = list(c(\"lat\", \"lon\"), c(\"min\", \"max\")))\n   # coordinates:\n   ret[1,1] <- as.numeric(xmlGetAttr(top[[nu[1]]], \"minlon\"))\n   ret[1,2] <- as.numeric(xmlGetAttr(top[[nu[1]]], \"maxlon\"))\n   ret[2,1] <- as.numeric(xmlGetAttr(top[[nu[1]]], \"minlat\"))\n   ret[2,2] <- as.numeric(xmlGetAttr(top[[nu[1]]], \"maxlat\"))\n  }\n  \n  # metadata\n  ##R# loads metadata according to XML shema and names the fields that are included\n  ## in the metadata of the GPX file\n  if(element==\"metadata\"){\n   lst <- c(\"name\",\"desc\",\"author\",\"copyright\",\"link\",\"time\",\"keywords\",\"bounds\",\n            \"extensions\")\n   nu <- which(names(top) %in% element)\n   if(!nu[[1]]==\"NULL\"){  \n    numlst <- which(lst%in%names(top[[nu]]))\n    lst2 <- c()\n    for( i in seq_along(numlst)){\n     lst2[i] <- lst[numlst[i]]\n    }\n    ret <- data.frame(NULL)\n    for(i in seq_along(numlst)) {\n     ret[1,lst2[i]] <- xmlValue(top[[nu]][[i]])\n    }\n   }\n  }\n }\n else { ret <- NULL }\n \n return(ret)\n}\n\n# enf of script;",
    "created" : 1379616755493.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3084413503",
    "id" : "AE496DA8",
    "lastKnownWriteTime" : 1379617243,
    "path" : "~/Rwork1/GitLocal/GPX_in_R/readGPX.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}