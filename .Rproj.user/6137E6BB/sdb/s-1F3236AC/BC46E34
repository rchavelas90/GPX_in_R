{
    "contents" : "#### http://lwlss.net/GarminReports/GarminFunctions.R\n#### Comments have been meade to ease the understanding of the script\n\n# Read in xml files from Garmin ForeRunner\nlibrary(XML)\nfilename=\"GPX_test_files/test_file_5_Garmin\"\n\ndoc=xmlParse(paste(filename,\".gpx\",sep=\"\"),useInternalNodes=TRUE)\n\n# We need to extract the simple tree structure containing\n# the data which we can pass to xmlToDataFrame\ntop=xmlRoot(doc)\ntitle=toString.XMLNode(top[[2]][[1]][[1]]) ##R# <Trk><name>\ndescription=toString.XMLNode(top[[2]][[2]][[1]]) ##R# <Trk><desc>\ndata=toString.XMLNode(top[[2]][[3]]) ##R# <Trk><trkseg>\n# All these tests in case description node is empty!\n# When it is, data node is moved up one\n# Really need to access nodes by name, but can't see how...\nif(data==\"NULL\") data=toString.XMLNode(top[[2]][[2]])\nif(data==\"NULL\") data=toString.XMLNode(top[[2]][[1]])\n\n# Fill a data frame with interesting data\ndf=as.data.frame(xmlToDataFrame(data,c(\"numeric\", \"character\", \"integer\")))\nif(toString.XMLNode(top[[2]][[3]])==\"NULL\") {\n if(toString.XMLNode(top[[2]][[2]])==\"NULL\") {\n  attribs=xmlSApply(top[[2]][[1]],xmlAttrs)\n }else{\n  attribs=xmlSApply(top[[2]][[2]],xmlAttrs)\n }\n}else{\n attribs=xmlSApply(top[[2]][[3]],xmlAttrs)\n}\ndf$lon=as.numeric(attribs[1,])\ndf$lat=as.numeric(attribs[2,])\n\n##R# Here the df is finished\n\ncolnames(df)=c(\"Elevation\",\"DateTime\",\"HeartRate\",\"Longitude\",\"Latitude\")\ndf$Elevation=as.numeric(df$Elevation)\ndf$HeartRate=as.integer(df$HeartRate)\ndf$DateTime=as.character(df$DateTime)\n##R# look at the structure of the columns\n##R# Elevation (num) DateTime (chr) HeartRate (int) Longitude (num) Latitude (num)\n\n# Convert timestamp to number of seconds since start of run\ndate=substr(df$DateTime[1],1,10) ##R# Obtains the date of the file, first 10 char\nTime=substr(df$DateTime,12,19) ##R# Obtains the times of the file,  char 12-19\n#head(df$DateTime)\n#head(Time)\nT0=strptime(Time[1],\"%H:%M:%S\") ## Starting time\nTime=as.numeric(strptime(Time,\"%H:%M:%S\")-T0) ## Elapsed time\n#head(Time)\ndf$Seconds=Time\n#head(df$Seconds)\n\n# Initialise columns\ndf$dNorth=0; df$dEast=0; df$dUp=0;\ndf$North=0; df$East=0; df$dDist=0; \ndf$dDist2D=0; df$Dist2D=0\n#head(df)\n#write.csv(df,file=\"GPX_to_CSV.csv\")\n\n# Haversine formula is appropriate for calculating distances from lat/long\nEarthRad=6371000 ##R# [in meters]\nhaverDist<-function(aLong,aLat,bLong,bLat){\n dLat=2*pi*(bLat-aLat)/360.0; dLon=2*pi*(bLong-aLong)/360.0\n a=(sin(dLat/2))^2+cos(2*pi*aLat/360)*cos(2*pi*bLat/360)*(sin(dLon/2)^2)\n return(EarthRad*2*atan2(sqrt(a),sqrt(1-a)))\n}\n\n\n# Calculate northings and eastings from location 0 to east and north coordinates\ndf$East=haverDist(df[1,\"Longitude\"],df[1,\"Latitude\"],df$Longitude,df[1,\"Latitude\"])*\n sign(df$Longitude-df[1,\"Longitude\"])\ndf$North=haverDist(df[1,\"Longitude\"],df[1,\"Latitude\"],df[1,\"Longitude\"],df$Latitude)*\n sign(df$Latitude-df[1,\"Latitude\"])\n\n##R# pruebas de datos\n##R# library(googleVis)\n##R# head(df2)\n##R# df2 <- data.frame(loc=numeric(6),factor=numeric(6))\n##R# df2$loc=paste(df$Latitude[1:6],df$Longitude[1:6],sep=\":\")\n##R# g2 <- gvisMap(df2,\"loc\",\n##R#               options=list(showLine=TRUE,useMapTypeControl=T))\n##R# plot(g2)\n\n# Calculate changes in position for each dt\nfor (x in 2:(length(df$DateTime)-1)) {\n sEast=sign(df[x,\"Longitude\"]-df[1,\"Longitude\"])\n sNorth=sign(df[x,\"Latitude\"]-df[1,\"Latitude\"])\n df$dEast[x]=sEast*haverDist(df[x-1,\"Longitude\"],df[1,\"Latitude\"],df[x,\"Longitude\"],df[1,\"Latitude\"]) ##R# Compute change in Eastings \n df$dNorth[x]=sNorth*haverDist(df[1,\"Longitude\"],df[x-1,\"Latitude\"],df[1,\"Longitude\"],df[x,\"Latitude\"]) ##R# Compute change inNortings \n df$dUp[x]=df$Elevation[x]-df$Elevation[x-1]\n # 2D distance (ignoring hills)\n df$dDist2D[x]=haverDist(df[x-1,\"Longitude\"],df[x-1,\"Latitude\"],df[x,\"Longitude\"],df[x,\"Latitude\"])\n}\n\n##R# head(df)\ndf$dDist=sqrt(df$dNorth^2+df$dEast^2+df$dUp^2)\ndf$Dist=cumsum(df$dDist)\ndf$Dist2D=cumsum(df$dDist2D)\n \n##R# options(digits=4)\n\n\n\n# Fit a spline function to the GPS coordinates & elevation\neast=splinefun(df$Seconds,df$East)\nnorth=splinefun(df$Seconds,df$North)\nup=splinefun(df$Seconds,df$Elevation)\ndist=splinefun(df$Seconds,df$Dist)\nhr=approxfun(df$Seconds,df$HeartRate) # Some gaps in heart rate record, linear interpolation more robust\n\n\n\n# Do finite centred differencing to give smoothest rate(speed)/gradient estimates\n##R# This is, to get the (Dist,Seconds) x+1 value minus the x-1 value to get the x (speed)\ndf$Speed=rep(0,length(df$Seconds))\ndf$Gradient=rep(0,length(df$Seconds))\nfor(x in 2:(length(df$Seconds)-1)){\n Dt=df[x+1,\"Seconds\"]-df[x-1,\"Seconds\"]\n Dd=df[x+1,\"Dist\"]-df[x-1,\"Dist\"]\n df[x,\"Speed\"]=Dd/Dt # m/s\n df[x,\"Gradient\"]=(df[x+1,\"Elevation\"]-df[x-1,\"Elevation\"])/Dd # m/m\n}\n\n##R# Complete values that werent taken into consideration with the finite centered dif.\n##R# Testing speed plot(df$Seconds[1:40],df$Speed[1:40],type=\"o\")\n##R# head(df)\n##R# require(ggplot2)\n##R# ggplot(df,aes(x=Longitude,y=Latitude))+\n##R# geom_path(aes(colour=Speed,size=\"50\"))\n##R# This plot can test the smoothing of the curve\n##R# ggplot(df,aes(x=Dist))+\n##R# geom_path(aes(y=Speed1,size=\"2\"))+\n##R# geom_path(aes(y=Speed2,color=\"red\",,size=\"2\"))\n\n##R# This plot graphs the elevation against the distance\n##R# ggplot(df,aes(x=Dist))+\n##R# geom_path(aes(y=Elevation,size=\"2\"))\n\n\ndf[1,\"Speed\"]=df[2,\"Speed\"]\ndf[length(df$Seconds),\"Speed\"]=df[length(df$Seconds)-1,\"Speed\"]\ndf[1,\"Gradient\"]=df[2,\"Gradient\"]\ndf[length(df$Seconds),\"Gradient\"]=df[length(df$Seconds)-1,\"Gradient\"]\n##R# head(df)\n##R# Record non-smooth speed\ndf$Speed1 <- df$Speed\n##R# head(df$Speed1)\n##R# Use only after smoothing speed\n\n\n\n# Smooth speed as it is unrealistically noisy\ndf$Speed=smooth(df$Speed)\n##R# Record smoothed speed\ndf$Speed2 <- as.numeric(df$Speed)\n##R# tail(df)\n##R# df[50:60,]\n##R#head(df)\n\n# Fit a spline function to rate (##R# speed)\nspeed=splinefun(df$Seconds,df$Speed)  # m/s\npace<-function(t) sapply(1/speed(t),max,0) \nppace<-function(t) 1000*pace(t)/60 ##R# Unit conversion from s/m to min/km\n\n##R# Testing the spline function and comparing its smoothness\n##R# speed(0)\n##R# tail(df)\n##R# speed(2720)\n##R# pace(2720)\n##R# 1/speed(2720)\n##R# pace(c(2720,2716,2711))\n\n##R# Test different speed columns\n##R# x <- 1:2720\n##R# par(mfrow=c(2,1),bty=\"l\",lab=c(10,10,0.5))\n##R# plot(x,speed(x),type=\"l\",xlim=c(0,2700),ylim=c(3,6))\n##R# head(df)\n##R# plot(df$Seconds,df$Speed2,type=\"l\",xlim=c(0,2700),ylim=c(3,6))\n##R# dev.off()\n\n##R# Reset par in graphics \n##R# resetPar <- function() {\n##R# dev.new()\n##R# op <- par(no.readonly = TRUE)\n##R# dev.off()\n##R# op\n##R# }\n##R# resetPar()\n\n# Update dataframe with speed and pace (after spline function)\ndf$Speed=speed(df$Seconds)\ndf$Pace=pace(df$Seconds)\n\n##R# This plot can test the smoothing of the curve and the spline (notice that it\n##R# does aparently nothing)\n##R# head(df)\n##R# str(df)\n##R# png(\"speed_time.png\",height=1000,width=4000,pointsize=1,res=300)\n##R# ggplot(df,aes(x=Seconds))+\n##R# geom_path(aes(y=Speed1),colour=\"blue\",linetype=1)+\n ##R# geom_path(aes(y=Speed2),colour=\"green\",linetype=1)+ ##R# See that spline fun is \"useless\" here\n##R# geom_path(aes(y=Speed),colour=\"red\",linetype=1)+\n##R# coord_cartesian(xlim = c(0, 2700), ylim=c(2, 5))\n##R# dev.off()\n\n\n# Generate some plots\nreportfile=paste(title,filename,\".pdf\",sep=\"\")\nprint(paste(\"Building\",reportfile))\npdf(reportfile)\n\n# Generate time interpolation points (##R# Time spaced in equal intervals  to get from 0 to max Time)\nNum=2001 \nminT=0; maxT=max(df$Seconds)\ninterT=minT+(maxT-minT)*(0:Num)/Num ##R# generate Num+1 numbers from minT to maxT (delta T * Frac)\n##R#tail(df)\n##R#tail(interT)\n\n# Create a colour function for plots\n##R# colorRampPalette returns a function that takes an integer argument and returns\n##R# that number of colors interpolating the given seuqnece\n##R# colfunc(5)\ncolfunc=colorRampPalette(c(\"navy\",\"white\", \"red3\"),space=\"Lab\")\ncp=colfunc(500)\ngetCol<-function(colFrac) cp[1+round(499*colFrac)]\n\n##R# source(\"Original_scripts_used/online_Hex_Color.R\")\n##R# testing colors\n##R# onlineHexColor(getCol(0.01))\n\n\n\n\n# Generate fractional variables for colouring plots\n##R# Funtion hr with parameter interT (time) [(Val-min)/(max-min)]\n##R# ******* This function computes a lot of sums, may be wise to simplify ir\nhrFrac=(hr(interT)-min(hr(interT)))/(max(hr(interT))-min(hr(interT))) ##R# Heart rate\nupFrac=(up(interT)-min(up(interT)))/(max(up(interT))-min(up(interT))) ##R# Elevation\n\n\n##R#******* This suggests to use an unknown pace for max value, be careful, could use a 95% quantile\npmax=min(c(60*7/1000,max(pace(interT)))) # Else scales ruined by stopping and walking\npFrac=(pace(interT)-min(pace(interT)))/(pmax-min(pace(interT))) ##R# Pace\n\n##R# Plotting the histogram - see how far is the max value of pace\n##R# head(df)\n##R# hist(pace(interT),breaks=30)\n\n##R# This function graphs the quantile distibtion of the pace, so that we can have a better\n##R# estimate of the max pace (stops must be considered, but not at this point)\n##R# library(\"ggplot2\")\n##R# qplot(Pace,data=df,geom=\"histogram\",binwidth=0.05)\n##R# c <- rnorm(10000,0,0.05) or pace(interT)\n##R# quantilePace <- quantile(pFrac,probs=seq(0,1,0.01))\n##R# probs <- names(quantilePace)\n##R# probs <- factor(probs,levels=probs)\n##R#  qplot(y=quantilePace,x=probs)\n##R# quantile(pace(interT),probs=0.95)\n\n\n# Calculate Color Scales\n##R# get length(cp) values (500) from the min hr to max hr (same for others)\nhrLevels=min(hr(interT))+(1:length(cp))*(max(hr(interT))-min(hr(interT)))/length(cp) ##R# Heart rate\nupLevels=min(up(interT))+(1:length(cp))*(max(up(interT))-min(up(interT)))/length(cp) ##R# Elevation\n##R# Computes the max pace, if it is greater that 7 min/km it overwrites it with #7\npmax=min(c(7,max(ppace(interT)))) # Else scales ruined by stopping and walking\npLevels=min(ppace(interT))+(1:length(cp))*(pmax-min(ppace(interT)))/length(cp) ##R# Pace\n\n##R# Trying to understand how everything is formed :P\n##R# library(\"ggplot2\")\n##R# qplot(Pace,data=df,geom=\"histogram\",binwidth=0.05)\n##R# c <- rnorm(10000,0,0.05) or pace(interT)\n##R# quantilePace <- quantile(pFrac,probs=seq(0,1,0.01))\n##R# probs <- names(quantilePace)\n##R# probs <- factor(probs,levels=probs)\n##R#  qplot(y=quantilePace,x=probs)\n##R# quantile(pace(interT),probs=0.95)\n\n\n# Make a plotting dataframe, calculate displacement during each timestep\nplt=data.frame(time=interT,east=east(interT),north=north(interT),up=up(interT),hr=hr(interT),distance=sapply(interT,dist),speed=speed(interT),pace=pace(interT))\n\n# Elevation trace\nlayout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))\nplot(NULL,xlab=\"East (m)\",ylab=\"North (m)\",xlim=c(min(df$East),max(df$East)),ylim=c(min(df$North),max(df$North)),main=paste(title,date))\nrect(par(\"usr\")[1], par(\"usr\")[3], par(\"usr\")[2], par(\"usr\")[4], col = \"grey\")\npoints(east(interT),north(interT),pch=16,cex=0.6,col=getCol(upFrac))\n# Draw legend\nimage(1, upLevels,matrix(data=upLevels, ncol=length(upLevels),nrow=1),col=cp,xlab=\"\",ylab=\"Elevation (m)\",xaxt=\"n\")\nlayout(1)\n\n# Heart rate trace\nlayout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))\nplot(NULL,xlab=\"East (m)\",ylab=\"North (m)\",xlim=c(min(df$East),max(df$East)),ylim=c(min(df$North),max(df$North)),main=paste(title,date))\nrect(par(\"usr\")[1], par(\"usr\")[3], par(\"usr\")[2], par(\"usr\")[4], col = \"grey\")\npoints(east(interT),north(interT),pch=16,cex=0.6,col=getCol(hrFrac))\n# Draw legend\nimage(1, hrLevels,matrix(data=hrLevels, ncol=length(hrLevels),nrow=1),col=cp,xlab=\"\",ylab=\"Heart Rate (bpm)\",xaxt=\"n\")\nlayout(1)\n\n# Pace trace\nlayout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))\nplot(NULL,xlab=\"East (m)\",ylab=\"North (m)\",xlim=c(min(df$East),max(df$East)),ylim=c(min(df$North),max(df$North)),main=paste(title,date))\nrect(par(\"usr\")[1], par(\"usr\")[3], par(\"usr\")[2], par(\"usr\")[4], col = \"grey\")\npoints(east(interT),north(interT),pch=16,cex=0.6,col=getCol(pFrac))\n# Draw legend\nimage(1, pLevels,matrix(data=pLevels, ncol=length(pLevels),nrow=1),col=cp,xlab=\"\",ylab=\"Pace (min/km)\",xaxt=\"n\")\nlayout(1)\n\n#####\nop<-par(mfrow=c(2,2))\n\n# Elevation timecourse\nplot(df$Seconds/60,df$Elevation,xlab=\"Time (min)\",ylab=\"Elevation (m)\",type=\"l\",lwd=2,col=\"red\")\n\n# Heart rate timecourse\nplot(df$Seconds/60,df$HeartRate,xlab=\"Time (min)\",ylab=\"Heart Rate (bpm)\",type=\"l\",lwd=2,col=\"red\")\n\n# Distance timecourse\n#plot(df$Seconds/60,df$Dist/1000,xlab=\"Time (min)\",ylab=\"Distance (km)\",type=\"l\",lwd=2,col=\"red\")\n\n# Speed timecourse\nplot(df$Seconds/60,60*df$Speed/1000,xlab=\"Time (min)\",ylab=\"Speed (km/min)\",type=\"l\",lwd=2,col=\"red\")\n\n# Pace timecourse\npmin=max(0,1000*min(df$Pace)/60)\npmax=min(7,1000*max(df$Pace)/60)\nplot(df$Seconds/60,1000*df$Pace/60,xlab=\"Time (min)\",ylab=\"Pace (min/km)\",type=\"l\",lwd=2,col=\"red\",ylim=c(pmin,pmax))\ntitle(\"Performance statistics with time (min)\",line=-2,outer=TRUE)\npar(op)\n\n#####\nop<-par(mfrow=c(2,2))\n\n# Elevation timecourse\nplot(df$Dist/1000,df$Elevation,xlab=\"Distance (km)\",ylab=\"Elevation (m)\",type=\"l\",lwd=3,col=\"blue\")\n\n# Heart rate timecourse\nplot(df$Dist/1000,df$HeartRate,xlab=\"Distance (km)\",ylab=\"Heart Rate (bpm)\",type=\"l\",lwd=2,col=\"blue\")\n\n# Distance timecourse\n#plot(df$Dist/1000,df$Dist/1000,xlab=\"Distance (km)\",ylab=\"Distance (km)\",type=\"l\",lwd=2,col=\"blue\")\n\n# Speed timecourse\nplot(df$Dist/1000,60*df$Speed/1000,xlab=\"Distance (km)\",ylab=\"Speed (km/min)\",type=\"l\",lwd=2,col=\"blue\")\n\n# Pace timecourse\npmin=max(0,1000*min(df$Pace)/60)\npmax=min(7,1000*max(df$Pace)/60)\nplot(df$Dist/1000,1000*df$Pace/60,xlab=\"Distance (km)\",ylab=\"Pace (min/km)\",type=\"l\",lwd=2,col=\"blue\",ylim=c(pmin,pmax))\ntitle(\"Performance statistics with distance (km)\",line=-2,outer=TRUE)\npar(op)\n\n#####\nop<-par(mfrow=c(1,2))\n\nhist(1000*plt$pace/60,breaks=21,xlab=\"Pace (min/km)\",ylab=\"Frequency\",main=\"\")\nhist(plt$hr,breaks=61,xlab=\"Heart Rate (bpm)\",ylab=\"Frequency\",main=\"\")\n\ntitle(\"Frequency histograms\",line=-2,outer=TRUE)\npar(op)\n\n#####\nop<-par(mfrow=c(2,2))\n\n# Pace gradient correlation\ngpCor=formatC(cor(df$Gradient,1000*df$Pace/60), digits=4)\nplot(df$Gradient,1000*df$Pace/60,col=\"red\",pch=16,xlab=\"Gradient\",ylab=\"Pace (min/km)\",main=paste(\"Correlation:\",gpCor))\n\n# Heart-rate gradient correlation\n# need to strip out warming up period\nminHR=mean(df$HeartRate)-1.98*sd(df$HeartRate)\ntimes=df$Seconds[df$HeartRate>=minHR]\nmint=min(times)\ndfHR=df[df$Seconds>mint,]\ngpCor=formatC(cor(dfHR$Gradient,dfHR$HeartRate), digits=4)\nplot(dfHR$Gradient,dfHR$HeartRate,col=\"red\",pch=16,xlab=\"Gradient\",ylab=\"Heart Rate (bpm)\",main=paste(\"Correlation:\",gpCor))\n\n# Pace time correlation\ngpCor=formatC(cor(df$Seconds,1000*df$Pace/60), digits=4)\nplot(df$Seconds,1000*df$Pace/60,col=\"red\",pch=16,xlab=\"Time (s)\",ylab=\"Pace (min/km)\",main=paste(\"Correlation:\",gpCor),\n     ylim=c(1000*min(df$Pace)/60,min(c(7,1000*max(df$Pace)/60))))\n\n# Heart-rate time correlation\ngpCor=formatC(cor(dfHR$Seconds,dfHR$HeartRate), digits=4)\nplot(dfHR$Seconds,dfHR$HeartRate,col=\"red\",pch=16,xlab=\"Time (s)\",ylab=\"Heart Rate (bpm)\",main=paste(\"Correlation:\",gpCor))\n\npar(op)\n\ndev.off()",
    "created" : 1380217018920.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3727111659",
    "id" : "BC46E34",
    "lastKnownWriteTime" : 1380213867,
    "path" : "~/Rwork1/GitLocal/GPX_in_R/Original_scripts_used/Read_XML_Garmin.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_source"
}